<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F12%2F25%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[图片测试]]></title>
    <url>%2F2019%2F12%2F24%2F%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[package localtest; import java.util.Collections; import java.util.PriorityQueue; /** * Created by IntelliJ IDEA. * * @Description: * @Author: 义云 * @Created: 2019-12-23 15:33 */ public class MedianFinder { private PriorityQueue&lt;Integer&gt; maxHeap; private PriorityQueue&lt;Integer&gt; minHeap; public MedianFinder() { // 使用有限队列实现一个大顶堆 this.maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); this.minHeap = new PriorityQueue&lt;&gt;(); } public void addNum(int num) { maxHeap.add(num); minHeap.add(maxHeap.peek()); maxHeap.poll(); // 平衡中 if (maxHeap.size() &lt; minHeap.size()) { maxHeap.add(minHeap.peek()); minHeap.poll(); } } public double findMedian() { if ((maxHeap.size() + minHeap.size()) % 2 == 0) { return maxHeap.peek() + minHeap.peek() / 2.0; } else { return maxHeap.peek(); } } /** * 利用大顶堆和小顶堆实现找中位数 * * @param args */ public static void main(String[] args) { MedianFinder medianFinder = new MedianFinder(); medianFinder.addNum(1); medianFinder.addNum(3); medianFinder.addNum(5); medianFinder.addNum(7); medianFinder.addNum(9); medianFinder.addNum(11); System.out.println(medianFinder.findMedian()); } }]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>3-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件项目交接明细]]></title>
    <url>%2F2019%2F01%2F11%2F%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E4%BA%A4%E6%8E%A5%E6%98%8E%E7%BB%86%2F</url>
    <content type="text"><![CDATA[软件项目项目交接是一件麻烦的事情，需要考虑很多事情，有一点没有考虑到，后期会给自己问题排查增加很多麻烦，基于此，列举了常见问题。 1.业务需求1.1 需求分析 项目需求分析及需求整理的最终文档 1.2 需求列表并对每个需求进行状态标记 已实现已上线、已实现未上线、未实现 1.3 产品设计方案 UI设计图、原型设计图、版本迭代规划文档、用户交互图 2.系统架构2.1 系统设计原则（分层架构（MVC），微服务，事件驱动） 从系统性能、安全、可用性、可扩展等方面阐述清楚系统设计优劣 2.2 系统整体设计 系统整体设计图及模块依赖图 2.3 模块设计 标记清楚功能说明及服务对象 2.4 业务流程 对应每个业务的流程图 3.技术选型3.1 前端技术栈 客户端（PC、Web、移动端），网络协议（HTTP/1.1、 HTTP/2），渲染引擎，脚本引擎，编译工具，包管理工具，开发工具及插件，库/框架（项目地址及对应版本） 3.2 后端技术栈 操作系统（Mac、Linux、Win），常规监控报警，持续集成，自动化运维，测试（单元测试、压力测试、全链路测试），虚拟化，容器技术 3.3 数据存储 数据库选型方案，表结构设计ER图及字段释义，非关系型数据库提供数据格式及描述，数据容灾设计方案 3.4 基础组件 Web Server(Nginx、 Tomcat、 Jetty)、缓存（本地缓存、远程缓存），消息队列（RabbitMQ、 Redis），定时任务，RPC（Dubbo、Thrift、gRPC），数据库中间件（连接池、分库分表），日志组件，配置中心，性能（容量评估、CDN网络、连接池），大数据（流式计算、Hadoop、Spark），搜索引擎（Elasticsearch、Solr），安全（加密算法、授权认证） 4.项目工程4.1 项目源代码 提供项目源代码及脚本工具,编码统一为UTF-8 4.2 项目迭代历史 自项目上线以来迭代历史记录文档 4.3 项目汇总列表 所有项目名称，实现功能，对应项目地址 4.4 开发规范 提供内部开发规范文档，如编程规范、常量定义、代码风格 4.5 内部接口API 所有API文档，文档包含接口功能描述、请求方式（POST,GET,PUT）、数据格式（XML,JSON）、请求参数、返回参数、版本号 4.6 外部接口API 依赖的第三方服务文档，文档包含服务名称、对接人、联系方式、账户密码 4.7 错误码定义 全量错误码枚举列表，包含错误码及对应语言描述信息 4.8 测试文档 测试文档，包含测试用例、测试数据、测试接口、测试步骤、测试结果及结果分析报告 5.其他5.1 账号密码及绑定的手机号 线上、线下登录环境密码、数据库、云主机、第三方服务商（阿里云、腾讯云）、第三方服务（数据、短信、图形验证码、邮件、基础组件） 5.2 域名管理 域名、备案信息、申请渠道、续费情况 5.3 机器 第三方服务，机密名/IP，系统及对应版本，配置信息，带宽，所运行服务 5.4 监控报警 报警通知人员修改，报警规则文档说明 5.5 设计专利 项目中涉及到的设计专利 5.6 上线部署文档 针对每个项目，给出对应的上线部署文档，环境依赖，详细操作步骤 5.7 用户操作手册 产品详细使用说明文档 5.8 重大故障列表 故障（网络瘫痪，系统崩溃等原因导致服务不可用而影响公司收入）发生时间，排查过程，解决方案进行汇总 5.9 Bug列表 项目自上线以来出现的问题，解决方法及状态（未解决，已解决）汇总列表 问题来源如下： 用户，运营人员在使用过程出现的问题（登录错误、页面找不到、服务异常）对应解决方案。 监控报警，技术人员收到报警信息及对应处理。 常见运维问题 5.10 新增需求列表 原需求没有，在使用过程中，由用户或运营人员提出的新需求，需求提出时间，完成状态（未开始、进行中、已上线） 5.11 数据报表 业务数据、日志数据、网站流量统计报表及数据增量报表]]></content>
  </entry>
  <entry>
    <title><![CDATA[cat+springboot初体验]]></title>
    <url>%2F2019%2F01%2F10%2Fcat-springboot%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[@[toc] 项目介绍项目地址介绍： cat是大众点评开源的一套基于java的实时应用监控平台，主要应用于服务中间件框架（MVC 框架、RPC 框架、持久层框架、分布式缓存框架）的监控，为开发和运维提供各项性能指标、健康检查、自动报警等可视化服务。 实战 关于项目介绍的文章已经很多了，现在想办法把服务搭建起来，看看项目效果如何，是否能达到自己的项目需求。未来方便起见，使用docker部署。 我的机器配置(腾讯云主机)： 1c2g Centos 7 Docker version 18.09.0, build 4d60db4 1. Cat服务器部署1.1容器构建先把项目从github拉取下来，进入到 docker目录，启动容器。(暂时只考虑单机部署), 这个构建过程可能需要20分钟左右。 git clone https://github.com/dianping/cat.git cd ./cat/docker docker-compose up安装过程遇见的问题：1.数据库并没有启动起来 cat-mysql | Initializing database cat-mysql | mysqld: Can&#39;t create/write to file &#39;/var/lib/mysql/is_writable&#39; (Errcode: 13 - Permission denied) cat-mysql | 2019-01-06T08:15:45.931202Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details). cat-mysql | 2019-01-06T08:15:45.932753Z 0 [ERROR] --initialize specified but the data directory exists and is not writable. Aborting. cat-mysql | 2019-01-06T08:15:45.932773Z 0 [ERROR] Aborting网上查了好多方法，试了下，都没怎么解决，最后修改docker-compose.yml文件，把mysql换成了mariadb数据库。 mysql: container_name: cat-mysql image: mariadb:10.2 # expose 33306 to client (navicat) # user: &quot;1000:50&quot; # user: &quot;1000&quot; ports: - 33306:3306 volumes: # change &#39;./docker/mysql/volume&#39; to your own path # WARNING: without this line, your data will be lost. - &quot;./mysql/volume:/var/lib/mysql/data&quot; # 第一次启动，可以通过命令创建数据库表 ： # docker exec 容器id bash -c &quot;mysql -uroot -Dcat &lt; /init.sql&quot; - &quot;../script/CatApplication.sql:/init.sql&quot; # command: mysqld -uroot --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci --init-connect=&#39;SET NAMES utf8mb4&#39; --innodb-flush-log-at-trx-commit=0 command: mysqld -uroot --character-set-server=utf8mb4 environment: - MYSQL_ALLOW_EMPTY_PASSWORD=yes - MYSQL_DATABASE=cat - MYSQL_USER=root - MYSQL_PASSWORD= 启动成功后通过docker ps会有两个容器启动 ➜ docker git:(master) ✗ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 869de049e824 docker_cat &quot;/bin/sh -c &#39;chmod +…&quot; 30 hours ago Up 30 hours 0.0.0.0:2280-&gt;2280/tcp, 0.0.0.0:8080-&gt;8080/tcp cat 695b3745e4b3 mariadb:10.2 &quot;docker-entrypoint.s…&quot; 30 hours ago Up 30 hours 0.0.0.0:33306-&gt;3306/tcp cat-mysql1.2 创建表# 进入mariadb 容器里面，查init.sql 文件是否存在 ➜ docker git:(master) ✗ docker exec -it 695b3745e4b3 /bin/bash root@695b3745e4b3:/# ls -l -rw-rw-r-- 1 1000 1000 15120 Jan 5 05:02 init.sql # 退出容器，创建数据库表 root@695b3745e4b3:/# exit ➜ docker git:(master) ✗ docker exec 695b3745e4b3 bash -c &quot;mysql -uroot -Dcat &lt; /init.sql&quot;1.3 配置 登录：http://211.159.147.25:8080/cat/s/login ，用户名：admin 密码：admin 通过浏览器配置(进入到Configs -&gt; 全局系统配置 -&gt; 客户端路由) 1 客户端路由路由配置(27.0.0.1 替换为你本机的实际的内网IP，比如说192.168.1.1) 服务端配置 (控制台,消费机,告警端,任务机) 2. 创建SpringBoot 项目2.1 通过maven添加依赖(另一种方式是直接下载cat-client-3.0.0.jar包) 通过mvnrepository cat-client只有3.0.0版本，引用的过程发现找不到这个包，又去看了cat源码的pom.xml文件，发现是增加了repositories依赖。 &lt;dependency&gt; &lt;groupId&gt;com.dianping.cat&lt;/groupId&gt; &lt;artifactId&gt;cat-client&lt;/artifactId&gt; &lt;version&gt;${cat.version}&lt;/version&gt; &lt;/dependency&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven2 Central Repository&lt;/name&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;unidal.releases&lt;/id&gt; &lt;url&gt;http://unidal.org/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;unidal.releases&lt;/id&gt; &lt;url&gt;http://unidal.org/nexus/content/repositories/releases/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 2.2 准备工作准备工作1 cat-client 要去/data/appdatas/cat/client.xml 找服务，进行数据上报。线上环境，应该由运维人员专人负责。mac 开发环境下，需要先修改写的权限，chmod -R 777 /data 创建 /data/appdatas/cat 目录，具有读写权限。 创建 /data/applogs/cat 目录 (可选) 创建 /data/appdatas/cat/client.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema&quot; xsi:noNamespaceSchemaLocation=&quot;config.xsd&quot;&gt; &lt;servers&gt; &lt;server ip=&quot;&lt;cat server ip address&gt;&quot; port=&quot;2280&quot; http-port=&quot;8080&quot; /&gt; &lt;/servers&gt; &lt;/config&gt; &lt;!-- 不要忘记把 `&lt;cat server IP address&gt;`替换成你自己的服务器地址哦！ --&gt; 准备工作2项目中创建 src/main/resources/META-INF/app.properties文件, 通过app.name 在 搜索对应的项目，这个也是必须得，在启动的时候会报错。 app.name={appkey} 对于项目启动的过程中出现的问题，可以通过tail -f /data/applogs/cat/cat_client_.log 查看对应日志，可以方便定位出现的问题。 3. API list Transaction如果不用URL集成组件，手动添加埋点，模板代码如下// 创建一个Transaction, `HelloController`看做一个类，一个类下面 `hello`具体方法 Transaction transaction = Cat.newTransaction(&quot;HelloController&quot;, &quot;hello&quot;); try { // 具体业务代码 t.setStatus(Transaction.SUCCESS);} catch (Exception e) { t.setStatus(e); Cat.logError(e);} finally { t.complete();} ![](transaction.png) * Event 记录事件成功事件Cat.logEvent(“URL.Server”, “serverIp”);Cat.logEvent(“URL.Server”, “serverIp”, Event.SUCCESS, “ip=${serverIp}”); 失败事件Cat.logError(e); * Metric (监控业务指标)Cat.logMetricForCount(“register”);Cat.logMetricForCount(“UserCount”, 3);Cat.logMetricForDuration(“UserCount”, 3); ## 4. demo中使用到的 [集成组件](https://github.com/dianping/cat/tree/master/integration) &gt; 这里面有一些集成的组件，可参考使用 * [URL监控埋点](https://github.com/dianping/cat/tree/master/integration/URL) : http请求过来会自动打点，记录所有的HTTP请求，即使错误的请求也会记录， - 对 shop/1 shop/2 都会自动归类到 /shop/{num} - shop/v1 shop/v2 等不会自动到/shop/v{num} * [Log4j2配置](https://github.com/dianping/cat/tree/master/integration/log4j2) ## CAT报表 * [Transaction报表](https://github.com/dianping/cat/blob/master/cat-doc/posts/ch1-report/transaction.md): 监控一段代码 `运行次数`，`OPS`，`错误次数`，`失败率`，`响应时间统计（平均影响时间、Tp分位值）`等等。 ![](Transaction报表.png) * [Event报表](https://github.com/dianping/cat/blob/master/cat-doc/posts/ch1-report/event.md): 同样监听一段代码的运行次数，和Transaction表表功能类似，缺少相应时间的统计。 * [Problem报表](https://github.com/dianping/cat/blob/master/cat-doc/posts/ch1-report/problem.md) 对一些异常，错误，响应时间过长（如：慢查询，网络延迟高），系统性能排查有用。 ![](Problem报表.png) * [Heartbeat报表](https://github.com/dianping/cat/blob/master/cat-doc/posts/ch1-report/heartbeat.md): 机器信息，JVM状态信息 ![](Heartbeat报表.png) * [Business报表](https://github.com/dianping/cat/blob/master/cat-doc/posts/ch1-report/business.md)： 偏重`业务指标`, 如`订单数`，`新注册用户数` ![](Business报表.png) [项目源代码 cat-spring-boot-demo](https://github.com/cuijianlong/cat-spring-boot-demo) # 参考 1. [Githup 介绍](https://github.com/dianping/cat) 2. [Docker 启动部分参考](https://github.com/dianping/cat/blob/master/cat-doc/posts/ch4-server/README.md) 3. [大众点评Cat监控系统的部署与操作说明](https://my.oschina.net/yanyimin/blog/1517724) 4. [MySQL docker 5.7.6 and later fails to initialize database](https://github.com/docker-library/mysql/issues/69) 5. [美团开源监控框架CAT-Spring Boot Demo](https://blog.csdn.net/chentravelling/article/details/84780086) 6. [深度剖析开源分布式监控CAT](https://tech.meituan.com/CAT_in_Depth_Java_Application_Monitoring.html) 7. [Cat 在线demo](http://unidal.org/cat/s/config?op=projects) user: admin pw: admin]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python脚本实现扇贝单词批量添加]]></title>
    <url>%2F2019%2F01%2F06%2FPython%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%89%87%E8%B4%9D%E5%8D%95%E8%AF%8D%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[获取单词&amp;正则匹配获取单词 import re # 单词写入文件 file = open(&quot;./EngWords.txt&quot;, &#39;w&#39;) lines = None wordscount = 0 # 正则匹配 `［`之前的单词 compiled_pattern = re.compile((r&#39;\w+(?=［)&#39;)) with open(&#39;./四级词汇词根+联想记忆法-俞敏洪.txt&#39;) as f: lines = f.readlines() for line in lines: #sub = re.search(r&#39;\w+(?=［)&#39;, line) sub = compiled_pattern.search(line) if sub is not None: wordscount +=1 file.write(sub.group(0) + &#39;\n&#39;) file.close() print(wordscount) 批量上传单词# 批量上传函数 def uploadWords(words): # words = &quot;status%0Asteady%0Ainclude%0Aresistance%0Aprime%0Aambassador&quot; words = words[:-2] url = &quot;https://www.shanbay.com/bdc/vocabulary/add/batch/?words=&quot; url = url + words + &#39;&amp;_=15467&#39; #querystring = {&quot;words&quot;: words} headers = { &#39;cookie&#39;: &quot;183787513; csrftoken=NbOu8iDgk7CSU5erpzJ80wdKoD3eBgF2; _ga=GA1.2.2039615932.1546739762; language_code=zh-CN; locale=zh-cn; sessionid=e30%3A1gfxi6%3A6&quot;, } response = requests.request(&quot;GET&quot;, url, headers=headers, params=querystring) if response.ok is not True: print(&quot;添加错误&quot;) return response # 读取单词并上传 with open(&#39;./EngWords.txt&#39;) as f: lines = f.readlines() words= &quot;&quot; wordscount = 0 requestcount = 0 for line in lines: words += line + &#39;%0&#39; wordscount +=1 if wordscount == 10: uploadWords(words) time.sleep(0.5) words = &quot;&quot; wordscount = 0 requestcount +=1 参考1.正则表达式操作]]></content>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox搭建Ubuntu虚拟机集群]]></title>
    <url>%2F2017%2F10%2F16%2FVirtualBox%E6%90%AD%E5%BB%BAUbuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[VirtualBox搭建Ubuntu虚拟机集群环境搭建 #1. ubuntu16.04镜像系统文件下载 #2. 安装教程(网上有详细的，就不重复造轮子了) 网络问题1. 络配置问题 默认情况下，VirtualBox使用的是NAT网络模式，这种模式可以通过主机访问外网，但是不能实现主机与虚拟机，虚拟机与虚拟机之间的通信，所以需要做相应的配置。 2. ubuntu16.04,如何修改网卡名称为eth0,wlan0 默认情况下，ubuntu16.04使用的网卡名不是eth0,如果需要修改为eth0,如何修改 问题参考知乎,经测试，此方法可行``` sudo vim /etc/default/grub 找到GRUB_CMDLINE_LINUX=””改为GRUB_CMDLINE_LINUX=”net.ifnames=0 biosdevname=0” 然后sudo grub-mkconfig -o /boot/grub/grub.cfg # 问题解决 ##1. VirtualBox提供的虚拟网卡类型 选项 特点 其他 NAT 虚拟机通过主机访问外网 虚拟机之间无法互相访问，主机无法访问虚拟机，外网可以通过端口转发 (port forwarding) 访问虚拟机。 Bridged 虚拟机通过主机网卡与外网桥接，有独立的IP 地址 虚拟机之间、虚拟机与主机之间、虚拟机与外网之间都可以互相访问。 Host-only 虚拟机通过Host-only网卡与主机之间建立内网 (192.168.56.0/24) 虚拟机之间、虚拟机与主机之间可以互相访问。虚拟机与外网之间无法互相访问。 Internal 虚拟机之间建立内网 虚拟机之间可以互相访问。虚拟机与主机之间、虚拟机与外网之间无法互相访问。 NAT Network 虚拟机之间建立内网，并通过主机访问外网 虚拟机之间可以互相访问。主机和外网无法访问虚拟机。 ##2. NAT网络转发 + 仅主机 的模式 1. virtualbox 全局设置，ctrl + G(Mac 是 command + G)步骤_1 步骤_2 步骤_3 2. virtualbox 虚拟机设置(局部设置)，ctrl + S(Mac 是 command + S) 虚拟机关闭的情况下，新建第二个网卡步骤_1 步骤_2 3. 开启虚拟机，虚拟机配置 修改/etc/network/interfaces文件vim /etc/network/interfaces 保存后重启系统即可 :reboot 解决复制粘贴的问题 由于我安装的是Ubuntu服务器镜像，所以没有所谓的输入输出驱动什么的，想要相互复制也就比较难了，另一个原因是VirtualBox虚拟机软件窗口大小也不好用， 所以，最好的解决办法自然是使用本地SSH登录了。 如果ssh连接失败，记得在安装：sudo apt-get install openssh-server $ 无界面打开 vboxmanage startvm “Ubuntu_16_1” –type headless $ 连接 ssh -p 2222 @localhost $ 关闭 vboxmanage controlvm UbuntuServer poweroff]]></content>
      <tags>
        <tag>VirtualBox</tag>
        <tag>ubuntu</tag>
        <tag>虚拟机</tag>
        <tag>网络配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thrift简介]]></title>
    <url>%2F2017%2F09%2F02%2FThrift%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Thrift简介简介Thrift提供了一种服务调用方式，由facebook开发，它的主要特点是次啊用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发。Thrift可以根据描述的服务接口生成多种语言，如C++，java，Python等等。与基于xml，json等消息格式的服务相比，其传输体积更小，对于高并发，大数据量和异构的系统更有优势。Thrift包含一个完整的堆栈结构用语构建客户端和服务端，整体架构如下： thrift 接口的两种实现方法IDL 接口定义语言((interface definition language))，用于跨语言的RPC服务接口的定义 基本类型 bool，布尔型，1个字节； byte，有符号单字节； i16，有符号16位整型； i32，有符号32位整型； i64，有符号64位整型； double，64位浮点数； string，字符串； binary，字节数组； 容器 map&lt;t1,t2&gt;，字典； list，列表； set，集合； 代码 结构定义 struct CommonResponse{ 1:optional i32 status, #状态码 0:成功 1:失败 2:optional string errorCode, #错误码 3:optional string errorMsg #错误信息 } struct OrderSearchDTO { 1: required i32 siteId; 2: optional list&lt;i32&gt; statusList; 3: optional bool isFlagshipOrder; 4: optional bool exOrderIdNotNull; 5: optional string originalFlightOrderId; } 服务接口定义namespace java com.xxx.flight.orderplatform.sdk.api.outer.plat.v1 include “MerchantOrderEntity.thrift” service MerchantOrderOperate { // 异步生单 CommonResponse updateOrderInfo4AsyncOrder(1: OrderSearchDTO orderSerchDTO);} ## thrift注解 Java注解： * @ThriftService * @ThriftStruct * @ThriftField * @ThriftEnumValue * @ThriftMethod * @ThriftConstructor * @ThriftField # 代码 * 结构定义 ```thrift @ThriftStruct public class NotifyPaidReqThriftVo extend xxx { private String paymentNo; private String paymentSeq; private String payType; private int payAmount; private String payTime; @Override public String paramValidateSelfDefined() { return null; } @ThriftField(21) public String getPaymentNo() { return paymentNo; } @ThriftField public void setPaymentNo(String paymentNo) { this.paymentNo = paymentNo; } @ThriftField(22) public String getPaymentSeq() { return paymentSeq; } @ThriftField public void setPaymentSeq(String paymentSeq) { this.paymentSeq = paymentSeq; } @ThriftField(23) public String getPayType() { return payType; } @ThriftField public void setPayType(String payType) { this.payType = payType; } @ThriftField(24) public int getPayAmount() { return payAmount; } @ThriftField public void setPayAmount(int payAmount) { this.payAmount = payAmount; } @ThriftField(25) public String getPayTime() { return payTime; } @ThriftField public void setPayTime(String payTime) { this.payTime = payTime; } } 接口 @ThriftService public interface FlagshipPayService { @ThriftMethod NotifyPaidResThriftVo notifyPaid(NotifyPaidReqThriftVo notifyPaidReqThriftVo); } 总结 本文只是对thrift进行简单的理解，从IDL和注解的两种方式使用thrift。并没有详细的介绍thrift的原理。后面理解深入了，补上。 参考：(1)thrift 的原理和使用(2)Thrift: The Missing Guide]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda的安装和使用]]></title>
    <url>%2F2017%2F04%2F10%2FAnaconda%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Anaconda的安装和使用 1. 什么是Anaconda官方的解释： Anaconda is the leading open data science platform powered by Python. The open source version of Anaconda is a high performance distribution of Python and R and includes over 100 of the most popular Python, R and Scala packages for data science. Additionally, you’ll have access to over 720 packages that can easily be installed with conda, our renowned package, dependency and environment manager, that is included in Anaconda. See the packages included with Anaconda and the Anaconda changelog Anaconda 是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。 2. Anaconda的安装官网下载 安装时，会发现有两个不同版本的Anaconda，分别对应Python 2.7和Python 3.5，两个版本其实除了这点区别外其他都一样。后面我们会看到，安装哪个版本并不本质，因为通过环境管理，我们可以很方便地切换运行时的Python版本。 3. Anaconda的使用# 创建一个名为python34的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本） conda create --name python34 python=3.4 # 使用activate激活某个环境 activate python34 # for Windows source activate python34 # for Linux &amp; Mac # 激活后，会发现terminal输入的地方多了python34的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH # 此时，再次输入 python --version # 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境 # 退出当前的环境 deactivate python34 # for Windows source deactivate python34 # for Linux &amp; Mac # 删除一个已有的环境 conda remove --name python34 --all # 列举当前环境中的所有依赖包 conda list # 安装某个新的依赖 conda install nltk 4. Jupyter Notebook在Conda安装之后，Jupyter Notebook是默认安装好的，直接在工作目录下打开即可: jupyter notebook你可以参阅Running the Notebook获取更多命令细节,后面在写一篇文章介绍jupyter的使用。 参考 Anaconda使用总结 官网 Python语法速览与机器学习开发环境搭建]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用pyenv+virtualenv打造多版本Python开发环境]]></title>
    <url>%2F2017%2F04%2F06%2F%E4%BD%BF%E7%94%A8pyenv-virtualenv%E6%89%93%E9%80%A0%E5%A4%9A%E7%89%88%E6%9C%ACPython%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[使用pyenv+virtualenv打造多版本Python开发环境1.pyenv的安装 pyenv的安装，非常简单，请参考 需要注意使用的是zsh，还是bash 2.pyenv的使用# 查看系统当前安装的python列表 $ pyenv versions # 查看可安装的python包有哪些 $ pyenv install --list # 安装python $ pyenv install -v 3.5.1 # 卸载python $ pyenv uninstall 2.7.3 3.python环境切换python优先级: shell &gt; local &gt; global # 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。 $ pyenv global 3.4.0 # 设置面向程序的本地版本 $ pyenv local 2.7.3 # 设置面向 shell 的 Python 版本 $ pyenv shell 3.2.1 4.使用 pyenv + virtualenv 打造多版本 Python 开发环境 创建虚拟环境: pyenv virtualenv 2.7.10 my-virtual-env-2.7.10 列出当前虚拟环境: pyenv virtualenvs 激活虚拟环境: pyenv activate 退出虚拟环境: pyenv deactivate 删除虚拟环境: pyenv uninstall my-virtual-env 参考 pyenv-virtualenv Linux 下的 Python 多版本管理]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pyenv virtualenv Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql数据库编码问题修改]]></title>
    <url>%2F2017%2F04%2F05%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[Mysql数据库编码问题修改1.问题描述 问题： 当向新建的表中插入数据时（包含中文的数据），发现 ERROR 1366 (HY000): Incorrect string value: &#39;\xE8\xAF\x82.查看字符编码问题$mysql&gt; show create table Deals\G *************************** 1. row *************************** Table: Deals Create Table: CREATE TABLE `Deals` ( `id` int(4) NOT NULL AUTO_INCREMENT, `date` date DEFAULT NULL, `code` int(4) DEFAULT NULL, `name` varchar(128) DEFAULT NULL, `price` double(16,2) DEFAULT NULL, `num` double(16,2) DEFAULT NULL, `totalPrice` double(16,2) DEFAULT NULL, `buyer` varchar(255) DEFAULT NULL, `seller` varchar(255) DEFAULT NULL, `type` varchar(128) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1 1 row in set (0.00 sec) 通过看表的字符，发现创建表使用的是latin1编码，这就是问题的关键 3.查看数据库配置编码mysql&gt; SHOW VARIABLES LIKE &#39;character%&#39;; +--------------------------+---------------------------------------------------------+ | Variable_name | Value | +--------------------------+---------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | latin1 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.16-osx10.11-x86_64/share/charsets/ | +--------------------------+---------------------------------------------------------+ 8 rows in set (0.03 sec) 通过这个配置，可以看出，character_set_connection,character_set_database, character_set_server 这几个配置都是latin1编码。 配置如下 mysql&gt; SET character_set_client = utf8 ; mysql&gt; SET character_set_connection = utf8 ; mysql&gt; SET character_set_database = utf8 ; mysql&gt; SET character_set_results = utf8 ; mysql&gt; SET character_set_server = utf8 ; mysql&gt; SET collation_connection = utf8 ; mysql&gt; SET collation_database = utf8 ; mysql&gt; SET collation_server = utf8 ; 修改完成后，我重启了应用，再次提交中文，搞定了！ 4.然而这样并没有解决问题对于现在已经创建的表格，字符依然是latin1，所以需要修改表的字符编码 查看数据库编码： ``` SHOW CREATE DATABASE db_name; mysql&gt; SHOW CREATE DATABASE BigDeal; +———-+——————————————————————–+| Database | Create Database |+———-+——————————————————————–+| BigDeal | CREATE DATABASE BigDeal /*!40100 DEFAULT CHARACTER SET latin1 */ |+———-+——————————————————————–+ * 查看表编码： SHOW CREATE TABLE tbl_name; mysql&gt; SHOW CREATE TABLE Deals\G*** 1. row *** Table: DealsCreate Table: CREATE TABLE Deals ( id int(4) NOT NULL AUTO_INCREMENT, date date DEFAULT NULL, code int(4) DEFAULT NULL, name varchar(128) DEFAULT NULL, price double(16,2) DEFAULT NULL, num double(16,2) DEFAULT NULL, totalPrice double(16,2) DEFAULT NULL, buyer varchar(255) DEFAULT NULL, seller varchar(255) DEFAULT NULL, type varchar(128) DEFAULT NULL, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=43 DEFAULT CHARSET=utf81 row in set (0.00 sec) * 查看字段编码： ``` SHOW FULL COLUMNS FROM tbl_name; mysql&gt; SHOW FULL COLUMNS FROM Deals; ``` * 把表默认的字符集和所有字符列（CHAR,VARCHAR,TEXT）改为新的字符集（和下面的区别，把默认修改为新的字符集）： ALTER TABLE tbl_name CONVERT TO CHARACTER SET character_name [COLLATE ...] 如：ALTER TABLE logtest CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci; * 只是修改表的默认字符集(修改默认)： ALTER TABLE tbl_name DEFAULT CHARACTER SET character_name [COLLATE...]; 如：ALTER TABLE logtest DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;* 修改字段的字符集： ALTER TABLE tbl_name CHANGE c_name c_name CHARACTER SET character_name [COLLATE ...]; 如：ALTER TABLE logtest CHANGE title title VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci; ## 参考 * [mysql修改表、字段、库的字符集](http://fatkun.com/2011/05/mysql-alter-charset.html) * [MySQL相关的中文编码错误解决](http://blog.sina.com.cn/s/blog_673faff10100qbyh.html)]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo建站记录]]></title>
    <url>%2F2017%2F04%2F01%2FHexo%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Hexo建站记录1.建站$ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install2.配置站点的_config.yml上传代码需要注意的配置 deploy: type: git repository: https://github.com/stegosauruscui/stegosauruscui.github.io.git branch: master3. package.json{ &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;3.2.2&quot; }, &quot;dependencies&quot;: { &quot;hexo&quot;: &quot;^3.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-searchdb&quot;: &quot;^1.0.3&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.2.0&quot; } }注意： hexo 更新到3.0之后，deploy的type 的github需要改成git 如出现在执行 hexo deploy 后,出现 error deployer not found:github 的错误，执行：npm install hexo-deployer-git –save 4.主题1. 安装next$ cd your-hexo-site $ git clone https://github.com/iissnan/hexo-theme-next themes/next2. 参考快速使用 主题配置 5.常用命令 hexo -d 上传到githup hexo -g 生成静态页面 hexo clean 清理 hexo new file 新建文件（写作页面） hexo s 启动服务 hexo new page tags 新建一个页面（首页，分类，about……） 6. 如何写文章 如图所示，只需要把需要分类的文章写在 categories： 后面,自然就会分类 7. 备份自己博客的源文件当你执行hexo d命令后，hexo-deployer-git仅仅把博客的静态文件上传到gitHup的master分支。如果后期需要更换电脑什么的该怎么找到自己的源文件编辑，所以备份博客的源文件变得很重要的一个步骤。 # git初始化自己的博客文件 $ git init --bare &lt;your_repo&gt;.git $ git add README.md $ git commit -m &quot;first commit&quot; # 创建一个hexoOrigin ，保存源文件分支， 在远程分支创建一个hexoOrigin，githup博客默认使用master分支 $ git checkout -b hexoOrigin $ git push -u origin hexoOrigin # 把源文件push到需要保存的分支 8.更换新的电脑或者文件路径，拉取源文件操作# 拉取远程分支 $ git git clone git@github.com:stegosauruscui/stegosauruscui.github.io.git # 顺序执行下面三个步骤即可 $ npm install hexo $ npm install $ npm install hexo-deployer-git $ hexo g # 生成静态文件 $ hexo s # 启动服务，测试是否正常 注意 注意push的时候确保自己的主题目录文件，比如我用的主题是next，是直接拉取github上的，里面有别人的git文件，导致我push的时候并没有把主题文件push到远程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的使用]]></title>
    <url>%2F2017%2F03%2F31%2FGit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git的使用git的使用 git文件状态流向 diff使用 基本命令# 配置个人信息 $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; # git目录初始化 $ git init # 文件添加到仓库 $ git add -p &lt;file&gt; $ git add . # 把文件提交到仓库 $ git commit -m &quot;add LICENSE&quot; # 查看仓库当前状态 $ git status # 查看difference $ git diff # 显示从最近到最远的提交日志 $ git log --pretty=oneline # 格式化输出信息 # 版本退回 $ git reset --hard HEAD^ # 当前版本HEAD,上一个版本HEAD^,上上个版本HEAD^^ $ git reset --hard 130f10a # 或HEAD~100 # 查看命令记录 $ git reflog # 丢弃工作区的修改，回到最近一次git commit或git add时的状态： $ git checkout -- README.md # 把暂存区的修改撤销掉（unstage） $ git reset HEAD READER.md # 从版本库中删除该文件 $ git rm README.md $ git commit -m &quot;remove READER.md&quot; # 把误删的文件恢复到最新版本，checkout其实用版本库里的版本替换工作区的版本 $ git checkout -- README.md 远程仓储 $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; # 测试是否成功 $ ssh -T git@github.com # 把一个已有的本地仓库与之关联 $ cd existing-project $ git init $ git add --all $ git commit -m &quot;Initial Commit&quot; $ git remote add origin ssh://git@git.sankuai.com/~cuijianlong/autoated_scrip.git $ git push origin master # 把本地库的所有内容推送到远程库上（推送master分支的内容） $ git push -u origin master # 向远程库推送更新 $ git push origin master # 从远程库克隆 $ git clone git@github.com:xxxx/xxxxx # 远程分支切换 $ git clone # 克隆远程代码 $ git branch -av # 查看远程分支和本地分支列表 $ git checkout remotes/origin/ceair $ git checkout ceair 分支管理# 创建+切换dev分支 $ git checkout -b dev # 相当于 $ git branch dev # 创建分支 $ git checkout dev # 查看当前分支，当前分支前面标有×号 $ git branch # 切换回master分支 $ git checkout master # 合并指定分支到当前分支 $ git merge dev # 删除dev分支 $ git branch -d dev # 查看分支合并情况 $ git log --graph --pretty=oneline --abbrev-commit # 修改readme.txt文件，并提交一个新的commit $ git add readme.txt $ git commit -m &quot;add merge&quot; # 切换回master $ git checkout master # 合并dev分支，请注意--no-ff参数，表示禁用Fast forward $ git merge --no-ff -m &quot;merge with no-ff&quot; dev # 如果需要临时修复Bug，可以把当前工作现场“储藏”起来，等Bug修复后恢复现场后继续工作 $ git stash list # 此时查看工作区是干净 # 切换到需要修复Bug的分支，创建临时分支来修复 $ git checkout master $ git checkout -b issue-101 # 修复完成后切换到master分支，完成合并，删除临时分支 $ git checkout master $ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 $ git branch -d issue-101 # Bug修复后，切换回dev分支继续干活 $ git checkout dev # 查看工作现场列表 $ git stash list # 恢复工作现场 $ git stash pop # 恢复的同时把stash内容也删了 $ git stash apply # 恢复，不删除stash的内容，使用git stash drop # 再次查看工作现场列表，干净 $ git stash list # 可以多次stash，恢复时指定恢复 $ git stash apply stash@{0} # 强行删除一个没有合并过的分支 $ git branch -D &lt;name&gt; # 要查看远程库的信息 $ git remote $ git remote -v # 推送其他分支 $ git push origin dev # 从远程库clone，默认情况只能看到master分支，需要在dev分支，必须创建远程origin的dev分支到本地 $ git checkout -b dev origin/dev $ git checkout -b branch-name origin/branch-name $ git branch --set-upstream branch-name origin/branch-name # 关联 # 向远程库推送dev有冲突 $ git pull # 抓取到本地合并解决冲突，再向远程推送 $ git push origin dev 标签管理# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 自定义 Git# 显示颜色，会让命令输出看起来更醒目 $ git config --global color.ui true # 忽略某些文件时，需要编写.gitignore，然后将.gitignore放到版本库中 # st就表示status $ git config --global alias.st status # 配置一个unstage别名 $ git config --global alias.unstage &#39;reset HEAD&#39; $ git unstage test.py # 等价于 $ git reset HEAD test.py # 显示最后一次提交信息 $ git config --global alias.last &#39;log -1&#39;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巨婴]]></title>
    <url>%2F2017%2F03%2F22%2F%E5%B7%A8%E5%A9%B4%2F</url>
    <content type="text"><![CDATA[巨婴什么是巨婴任何心理障碍本质上都是一种关系障碍。 -----《巨婴国》对于这个世界的认知，让我想起了三个伟人。第一个是哥白尼，他提出了日心说，让我们明白意识到我们的自大，我们并不是宇宙的中心，太阳才是银河系的中心；第二个是达尔文，他让我们意识到我们和其他动物并没有区别，我们人类也是通过进化而来，我们不是女娲捏的小人，也不是上帝造的人。第三个事佛洛伊德，他发现了人类的行为和所有的认知，甚至是理性是像汪洋大海一样的潜意识。 我们生活在这个大社会中，会接触各式各样的人，与其他人打交道， 我们不可能把自己孤立起来，让自己封闭。但是我们思考这个社会的时候总是习惯用自己的思维模式去思考他人，这种心理模式就是停留在婴儿期。每个人有自己的想法，有自己喜欢的兴趣爱好，做想自己喜欢做事的权利，只要这个喜好在国家法律允许的范围，不损害他人的利息，我觉得我都可以接受，为什么去干扰呢？ 当我们刚来到这个社会，我们还是个婴儿，不懂任何事，我们唯一的会做的就是吃，饿了就会哭，拉屎了有妈妈给我们换尿布，不开心了我们也会哭，我们的状态无法就是两种，高兴或者不高兴。我们就像神一样的存在，以自我为中心，完全不顾爸爸妈妈的感受。现在我们长大了，似乎我们还没有走出来，我们虽然不像小时那么依赖他人，但是我们还是喜欢用那样的方式去思考问题。虽然我们现在长大了，成人了，但是我们的心理反应模式还是停留在婴儿期，变成了巨婴。 巨婴的特点让我们穿越时光的隧道，回到我们的婴儿时期，去寻找那些快要遗失的记忆。简明扼要的总结出婴儿以下三个特点: 母婴共生 全能自恋 偏执分裂 第一个母婴共生就是我们小时候所有的行为都离不开母亲的照顾，我们生下来是没有生存能力的，我们的吃喝拉撒都需要母亲的照顾，当然也分清自我和外界的区别，这个时候，婴儿和母亲是完全的共生体。 第二个全能自恋这个特点，这个很明显，在婴儿身上能很明确的看到，完全靠主管念想，想吃就吃，想喝就喝，不高兴就哇哇大哭，这个时候就会有人来照顾它，这个感觉就像有的人喜欢猫，给猫买吃的，给猫铲屎，完全就是猫奴，完全靠自己的信念执行，不然就会用出的最强杀招，这就是全能自恋。 第三条就是偏执分裂，在我们婴儿时期，认识世界的维度只有两个，那就是喜欢或者不喜欢，恶魔或者天使，好人或者坏人，这个就像计算机世界一样true or false。对于我们喜欢的事情，我们就特别想要得到，对于我们讨厌的事情，我们就无法接受，这和我们好多人的想法是一样的，对于一些我们不能接受的事情，我们就认为它是变态的。 如何让自己不是巨婴 觉知，让自己变得独立，相信自己是强大的，遇见任何事情，不要退缩，为什么不去挑战下呢 多一份关爱，多考虑下他人的感受我们遇事首先考虑是自己，我们为什么不站在他人的角度考虑问题呢，多关心下他人。 行动，永远不要停留在大脑中生活，踏出行动，面临行动。]]></content>
      <categories>
        <category>思想</category>
      </categories>
      <tags>
        <tag>思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[polysh查看多台服务器的日志]]></title>
    <url>%2F2017%2F03%2F22%2Fpolysh%E6%9F%A5%E7%9C%8B%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[olysh 的使用]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>polysh</tag>
      </tags>
  </entry>
</search>
